Reflection 13th july

1. To implement recursion, first implement the base or the stopping condition.
2. Ctrl-Alt-k kills an entire expression.
3. When unsure about the number of arguments that will be passed to a function we use &, as in (defn func [ arg1 & rest] , the rest of the arguments are stored in 'rest' as a sequence.
4. Concat takes two sequences as arguments. We cannot concat a sequence and a single number.
5. Concat takes more than two sequences , while conj and cons take one sequence and one or more numbers.
6. Compliment is a special type of function which takes a function as an argument and returns a function as well.
7. Ctrl-Shift-k also kills an entire expression.


Mistakes
1. Used defn instead of def while using compliment function to create another function.
2. While writing my-complement function, returned the expression (not f) instead of a function.


Reflection 14th july

1. Test Driven Development is a strategy in which we write the test cases first and then write the actual function.
2. Writing the test case makes us understand the function input, output and behaviour better.
3. We can use test libraries to write tests, clojure has a inbuilt test library called clojure.test
4. Expectations is a library to write and check tests, auto-expectations makes the job easier by running the tests everytime a test file or core file is modified and saved and lists the tests which were failed.
5.When a test fails, expectations also shows how the expected and actual outputs differ.
6.To replace all the occurences of a string with another string we can use 'M-%', then we type the text to be replaced press enter, followed by replacement text then press 'y' or 'n' for each occurence or '!' to replace all further occurences.
7.Write the test for a function, before writing the test function.


15th july

TO DO :
1.Read chapter 5
2.Implement comp function
3.Write the game.

Reflection :
1.While writing tests, we divide the whole task into pure functions, and one impure function which deals with input output or database.
2.Pure functions are referentially transparent i.e. their output depends only on their arguments and on immutable data.
3.Pure functions do not create side effects. However we need impure functions to create visible output ex. println is an impure function.
4.When using recursion, each recursive call to the function creates a new scope in which the arguments are bind to different values and not mutated.
5.Creating a lot of intermediate values while running a recursive program does not crash it because internally clojure's immutable data structures are implemented using structural sharing.
6.Combining functions so that the return value of one function is passed as an argument to another function is called functional composition.
7.Int function rounds up a number to the lower integer. Ex. (int 4.7) = 4
8.Since pure functions return the same value for the same argument, we can use 'memoize' to cache the results of the function, so when next time the funciton is called it returns the stored result. This saves the time and cost of calling the function again.
9.Like get-in is used to retreive a value from a nested map, assoc-in is used to create a nested map.
10.Reduce function can be used to compose functions, by passing it a sequence of functions.
11.lazy-seq is used when we need a conceptually infinate list. We then use 'take n' to get the first n numbers from the infinate list.
12.The members of the lazy sequence are computed only when they are required. When a member is required clojure also computes the next 31 members and keeps ready for better performance.
13.Range is a lazy sequence generator, while take materializes a lazy sequence. Most other functions work with lazy sequence and give lazy sequence.
14.if-let : lets you check a condition and bind its value if truthy to a name at once.
15.Partial can be used when we have to apply multiple parameters to a function many times but one or more parameters remain the same always.


17th july
TODO
1.chapter 6
2.peg-game

Reflections:

If you do not have time to do it correctly, you definately do not have time to do it wrong.
Namespace helps to find a given object (function or data) with its name.
Anything we write is treated as a symbol by clojure unless we quote it.
def creates a association between the variable name and the variable itself in the current namespace's map.
When we call def again with the same variable name, it gets binded to the new variable and the previous binding is lost.
'in-ns' is used to switch to a namespace if it exits and if not then create the namespace and switch to it.
To use functions and data from other namespaces we have to use fully qualified symbol i.e. namespace/name.
Calling 'refer' with a namespace symbol lets you refer to the corresponding namespace's object wihtout having to use fully qualified sybols.
'defn-' defines a private function which can be used only within the namespace in which it is defined and cannot be refered from another namespace.
'alias' can be used to sorten a namespace name for using fully qualified symbols
We can use 'require' to use functions from other namespaces, we can call refer after that to use the functions directly.
'use' does the job of require and refer at once.
'refer-clojure' is used to refer to clojure.core, but when we are in user namespace, clojure.core is refered automatically.
Also when we use 'ns'macro, clojure.core is refered by default.
We don't have to quote symbols within ns.


19th july

Reflection
Stackoverflow occurs when we have a recursive function and it is called a large number of times.
In case of functions which work over a very large data (ex. 10001 prime) we should try use inbuilt functions rather than recursion to avoid stackoverflow.
'Meta-x + undo-tree-visualize' can be used to easily navigate through undo history and choose what we want to replace.
Use 'let' when you have to compute a value multiple times or when a function produces side effects.
Variable and function names should be self-explanatory, when they can't be use comment or documentation.
'letfn' is used to create local function which are only accessible within the function where defined.
Documentation string should be written before the parameters list of a function.
range, map etc all work on lazy sequences and return a lazy sequence.
Try to use inbuilt functions instead of writing your own recursive function as far as possible.
'narrow' is a minor mode which shows only the highlighted part of the text and hides other. the shortcuts are 1. C-x n n to narrow down. 2. C-x n w to widen
'some' can also be used to return a value other than true and nil if used with a proper function.



20th july

Today all the functions which i wrote, i did them using inbuilt functions and without recursion.
Now it's easier to think in terms of inbuilt functions of clojure.

':when' keyword is used in for loop to check for a condition and return that value when true.
Instead of 'filter (not function)' we should use 'remove'
A list can be created using the 'list' function.
Java functions like Integer.ParseInt can be used within clojure.
