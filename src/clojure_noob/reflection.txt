Reflection 13th july

1. To implement recursion, first implement the base or the stopping condition.
2. Ctrl-Alt-k kills an entire expression.
3. When unsure about the number of arguments that will be passed to a function we use &, as in (defn func [ arg1 & rest] , the rest of the arguments are stored in 'rest' as a sequence.
4. Concat takes two sequences as arguments. We cannot concat a sequence and a single number.
5. Concat takes more than two sequences , while conj and cons take one sequence and one or more numbers.
6. Compliment is a special type of function which takes a function as an argument and returns a function as well.
7. Ctrl-Shift-k also kills an entire expression.


Mistakes
1. Used defn instead of def while using compliment function to create another function.
2. While writing my-complement function, returned the expression (not f) instead of a function.


Reflection 14th july

1. Test Driven Development is a strategy in which we write the test cases first and then write the actual function.
2. Writing the test case makes us understand the function input, output and behaviour better.
3. We can use test libraries to write tests, clojure has a inbuilt test library called clojure.test
4. Expectations is a library to write and check tests, auto-expectations makes the job easier by running the tests everytime a test file or core file is modified and saved and lists the tests which were failed.
5.When a test fails, expectations also shows how the expected and actual outputs differ.
6.To replace all the occurences of a string with another string we can use 'M-%', then we type the text to be replaced press enter, followed by replacement text then press 'y' or 'n' for each occurence or '!' to replace all further occurences.
7.Write the test for a function, before writing the test function.


15th july

TO DO :
1.Read chapter 5
2.Implement comp function
3.Write the game.

Reflection :
1.While writing tests, we divide the whole task into pure functions, and one impure function which deals with input output or database.
2.Pure functions are referentially transparent i.e. their output depends only on their arguments and on immutable data.
3.Pure functions do not create side effects. However we need impure functions to create visible output ex. println is an impure function.
4.When using recursion, each recursive call to the function creates a new scope in which the arguments are bind to different values and not mutated.
5.Creating a lot of intermediate values while running a recursive program does not crash it because internally clojure's immutable data structures are implemented using structural sharing.
6.Combining functions so that the return value of one function is passed as an argument to another function is called functional composition.
7.Int function rounds up a number to the lower integer. Ex. (int 4.7) = 4
8.Since pure functions return the same value for the same argument, we can use 'memoize' to cache the results of the function, so when next time the funciton is called it returns the stored result. This saves the time and cost of calling the function again.
9.Like get-in is used to retreive a value from a nested map, assoc-in is used to create a nested map.
10.Reduce function can be used to compose functions, by passing it a sequence of functions.
11.lazy-seq is used when we need a conceptually infinate list. We then use 'take n' to get the first n numbers from the infinate list.
12.The members of the lazy sequence are computed only when they are required. When a member is required clojure also computes the next 31 members and keeps ready for better performance.
13.Range is a lazy sequence generator, while take materializes a lazy sequence. Most other functions work with lazy sequence and give lazy sequence.
14.if-let : lets you check a condition and bind its value if truthy to a name at once.
