Reflection 13th july

1. To implement recursion, first implement the base or the stopping condition.
2. Ctrl-Alt-k kills an entire expression.
3. When unsure about the number of arguments that will be passed to a function we use &, as in (defn func [ arg1 & rest] , the rest of the arguments are stored in 'rest' as a sequence.
4. Concat takes two sequences as arguments. We cannot concat a sequence and a single number.
5. Concat takes more than two sequences , while conj and cons take one sequence and one or more numbers.
6. Compliment is a special type of function which takes a function as an argument and returns a function as well.
7. Ctrl-Shift-k also kills an entire expression.


Mistakes
1. Used defn instead of def while using compliment function to create another function.
2. While writing my-complement function, returned the expression (not f) instead of a function.


Reflection 14th july

1. Test Driven Development is a strategy in which we write the test cases first and then write the actual function.
2. Writing the test case makes us understand the function input, output and behaviour better.
3. We can use test libraries to write tests, clojure has a inbuilt test library called clojure.test
4. Expectations is a library to write and check tests, auto-expectations makes the job easier by running the tests everytime a test file or core file is modified and saved and lists the tests which were failed.
5.When a test fails, expectations also shows how the expected and actual outputs differ.
6.To replace all the occurences of a string with another string we can use 'M-%', then we type the text to be replaced press enter, followed by replacement text then press 'y' or 'n' for each occurence or '!' to replace all further occurences.
7.Write the test for a function, before writing the test function.


15th july

TO DO :
1.Read chapter 5
2.Implement comp function
3.Write the game.

Reflection :
1.While writing tests, we divide the whole task into pure functions, and one impure function which deals with input output or database.
2.Pure functions are referentially transparent i.e. their output depends only on their arguments and on immutable data.
3.Pure functions do not create side effects. However we need impure functions to create visible output ex. println is an impure function.
4.When using recursion, each recursive call to the function creates a new scope in which the arguments are bind to different values and not mutated.
5.Creating a lot of intermediate values while running a recursive program does not crash it because internally clojure's immutable data structures are implemented using structural sharing.
6.Combining functions so that the return value of one function is passed as an argument to another function is called functional composition.
7.Int function rounds up a number to the lower integer. Ex. (int 4.7) = 4
8.Since pure functions return the same value for the same argument, we can use 'memoize' to cache the results of the function, so when next time the funciton is called it returns the stored result. This saves the time and cost of calling the function again.
9.Like get-in is used to retreive a value from a nested map, assoc-in is used to create a nested map.
10.Reduce function can be used to compose functions, by passing it a sequence of functions.
11.lazy-seq is used when we need a conceptually infinate list. We then use 'take n' to get the first n numbers from the infinate list.
12.The members of the lazy sequence are computed only when they are required. When a member is required clojure also computes the next 31 members and keeps ready for better performance.
13.Range is a lazy sequence generator, while take materializes a lazy sequence. Most other functions work with lazy sequence and give lazy sequence.
14.if-let : lets you check a condition and bind its value if truthy to a name at once.
15.Partial can be used when we have to apply multiple parameters to a function many times but one or more parameters remain the same always.


17th july
TODO
1.chapter 6
2.peg-game

Reflections:

If you do not have time to do it correctly, you definately do not have time to do it wrong.
Namespace helps to find a given object (function or data) with its name.
Anything we write is treated as a symbol by clojure unless we quote it.
def creates a association between the variable name and the variable itself in the current namespace's map.
When we call def again with the same variable name, it gets binded to the new variable and the previous binding is lost.
'in-ns' is used to switch to a namespace if it exits and if not then create the namespace and switch to it.
To use functions and data from other namespaces we have to use fully qualified symbol i.e. namespace/name.
Calling 'refer' with a namespace symbol lets you refer to the corresponding namespace's object wihtout having to use fully qualified sybols.
'defn-' defines a private function which can be used only within the namespace in which it is defined and cannot be refered from another namespace.
'alias' can be used to sorten a namespace name for using fully qualified symbols
We can use 'require' to use functions from other namespaces, we can call refer after that to use the functions directly.
'use' does the job of require and refer at once.
'refer-clojure' is used to refer to clojure.core, but when we are in user namespace, clojure.core is refered automatically.
Also when we use 'ns'macro, clojure.core is refered by default.
We don't have to quote symbols within ns.


19th july

Reflection
Stackoverflow occurs when we have a recursive function and it is called a large number of times.
In case of functions which work over a very large data (ex. 10001 prime) we should try use inbuilt functions rather than recursion to avoid stackoverflow.
'Meta-x + undo-tree-visualize' can be used to easily navigate through undo history and choose what we want to replace.
Use 'let' when you have to compute a value multiple times or when a function produces side effects.
Variable and function names should be self-explanatory, when they can't be use comment or documentation.
'letfn' is used to create local function which are only accessible within the function where defined.
Documentation string should be written before the parameters list of a function.
range, map etc all work on lazy sequences and return a lazy sequence.
Try to use inbuilt functions instead of writing your own recursive function as far as possible.
'narrow' is a minor mode which shows only the highlighted part of the text and hides other. the shortcuts are 1. C-x n n to narrow down. 2. C-x n w to widen
'some' can also be used to return a value other than true and nil if used with a proper function.



20th july

Today all the functions which i wrote, i did them using inbuilt functions and without recursion.
Now it's easier to think in terms of inbuilt functions of clojure.

':when' keyword is used in for loop to check for a condition and return that value when true.
Instead of 'filter (not function)' we should use 'remove'
A list can be created using the 'list' function.
Java functions like Integer.ParseInt can be used within clojure.
're-seq' returns a lazy sequence of successive matched of pattern in a string.
'partition' is used to create subsequences from a sequence, we can specify the size and offset of the subsequences.
'(take (drop )' is equivalent to partition.

Completed all the 12 problems of project euler, implemented my-range function, solved problems of 4 clojure upto 37.





21th July.

Reflection.

'git' is a de-centralized version control system.
In decentralized vcs origin need not be a server, it cab be a directory like USB drive too.
Every commit is an object in git.
'git remote --verbose show' shows the current fetch and pull origin.
To avoid conflicts use rebase and then push.
Pull, pulls code and the meta-data too.
'clojure.pprint/pprint' prints the contents of a nested list in a readable manner.
'->>' is called threading macro and it's used to make the code readable in topdown manner, it passes the return of first expression to the next and so on.
'->' does the same, except that it sends the result of an expression to the first argument of next.
'some ->>' if any value is nill, then it returns nill and doesn't pass to the next expression. if not then it returns the return of last expressiom. It can be used to avoid 'null pointer exception'
'slurp' is used to read a text file.
Java's parseInt method can be used in clojure too, to get a number from a string input.
'Interleave' returns a lazy-seq of the first item in each seqence then the second etc.
'Interpose' reutrns a lazy seq of the elements of input sequence separated by the given separator.
'drop-last' drops the last element of a sequence.

22nd July

Thank you so much for your valuable feedback sir, i tried to implement all the modifications that you mentioned.
I wanted to ask you about ^Character c, but that time you were not around and i forgot later, i'll come to you tomorrow for explanation.

Reflection of 22nd july.



'distinct' function returns a lazy sequence with the duplicates in the input sequence removed.
'distinct?' returns true if no two of the given arguments are equal.
(iterate f x) returns a lazy sequence of x, (f x), (f (f x)) etc.
partition-by takes a function and a sequence, applies function to each value in sequence and splits it each time function returns a new value.
partition-all is used when the sequence may have partitions with fever than n items in the end.
'contains?' returns true if the given key is present in the map or sequence.
'compare' compares two values and returns a negative or a postive number when not equal depending upon which is greater and zero when both are equal.
'remove' function takes a predicate function and a list, and removes all the elements from the list which do not satisfy the predicate function.
'get-in' can be given a default value to return when the given index is not found in the array.
'if' 'when' 'and' etc are not fuctions but special forms, in which the expressions are not evaluated before passing.
macros are used to define special forms.


Reflection 25th July.

inc' is similar to inc , but the former does not give integer overflow when given a very big number.
zipmap is used to create a map by giving a sequence of keys and values.
'html' is used to create static web documents which may contain link to other documents.
There are two types of tags in HTML, block tags and inline tags. block tags have a new line at the end and beginning
Semantic markup stresses that hierarchy should be based on the context which has several advantages, like easier for readers to read , plus also helps search engine to get the relevant content.
current version of html is html5 which has new tags like audio, video etc.
tags can be assigned to a class, the style of which can be controlled by a css file.
we can assign multiple classes to the same element.
clojurescript code compiles to javascript bytecode.
'G-closure' library helps in optimizing the compliled javascript files.
'minification' makes a js file smaller by removing unnecessary white spaces, comments etc. so as to reduce download time of the webpage.
'obfuscation' helps prevent copying of code, by making it confusing ex. by making variable names non-relatable.
All the functions of javascript can be used in clojurescript.
The html file index.html has the path of compiled javascript file, when the html file is loaded the javascript file is run.



Reflection 28th July.

Immutability makes it dificult for the front end to maintain states, so we use Software Transactional memory (STM)
STM is usually used only in the front end, because back end has database to maintain states.
STM improves speed, because front end does not depend upon backend for maintaining states.
STM has properties like, atomicity isolation consistency and durability.
Atomicity means that a partiular transaction is indivisible , it must either complete or fail but can't be in an intermediate state.
Isolation- Two transactions are independent of each other.
Consistency - Changes in the databse should be consistent everywhere.
Durability - Changes in the db should happen in all the copies of the db.
Atom is used in stm, it is syncronous and uncordinated.
(atom nil
      []
      {})
      is the basic syntax to create an atom, an atom can store a number, an array or a map.
When we want to store multiple values in an atom we can use map effectively.
To change values in an atom , we use the swap! function, which updates the value of the atom, using the function supplied to it. Ex. (swap! a inc) will increment the value in atom a.
Value of an atom can be accessed using '@' , ex. @a will give the value i.e. a number, vector , map etc.
Value of an atom can be reset to any value using reset! function.



Reflection 31st July.

(atom 0 :validator even?) When :validator is used while defining an atom we can only assign those values to the atom which satisfy the function following :validator keyword.
Use mapv instead of map in clojure-script, because map returns a lazy sequence and javascript doesn't understand lazy sequences. mapv returns a vector which is not lazy.
Whenever there is repitation in a html file, we can use functions to render the html.
React is a library developed by facebook for front-end development. It changes the DOM depending upon an input.
React uses a virtual DOM and calulates the diff betweeen current and previous DOM and re-writes only the changes improving the performance.
Reagent provides binding, render function and r-atom to use react in clojure-script
As soon as the value of the r-atom is modified, it calls the render function and renders the changes into the html file.
Functions which define a component in reagent are called using square brackets. If we use round brackets then the function will be called each time even if nothing has changed in the component.
An exclamation mark in function name is a convention to signify that the function causes side-effects like modifying an atom.
peek function returns the first value of a list, and last value of a vector. In case of vectors it is much more efficient than last.






Reflection 2nd Aug.

Whenever asking for help, while explaining your code first show the data structure which you have used.
Use array of maps instead or map of map, to use inbuilt functions effectively. Although depending upon the use case we may use the first.
M-x --> revert-buffer will reload the buffer from the disk.
When we create a new project using lein with reagent template, cljc directory has all common code which can compile to java and javascript both.
Meta-/ autocompletes a variable name or a function name by looking at the buffer above the current postion.
We can directly de-structure a sequence into the parameter declaration of a function. Ex. (fn [[a b]]) if a sequence if passed to the fn, it will automatically get destructured to a and b.
(map-indexed f coll) returns a lazy sequence by applying f to 0 and first element of coll, then to 1 and second element of coll and so on, until coll is exhausted. Function f should accept two arguments, index and item.
sql databases have a structure, example a table. It requires less storage but has less flexibility.
nosql databases store data as a collection of records , the records can be a map or a nested map.
nosql db is useful for evolutionary programming, while sql db requires less space and is faster.
mongodb is a nosql database it stores maps in json files.
monger is a clojure-library which converts clojure maps into json files understandable by mongodb.
luminus allows to create directory structure and files depending upon our type of project.


Yesterday I implemented the spiral traversal program.
Today I extended the logic to create the game for two players, not actually the game but the logic behind it.
I only had to change the arr-maker function, which returns the counts at which direction should be changed.
The only change is size is decremented by 2, instead of 1.

(defn arr-maker-2
  "Returns count on which direction needs to be changed
  for two player spiral game.
  Almost similar to arr-maker excpet that it decrements the
  size by 2 instead of 1"
  ([size] (arr-maker-2 (- size 2) [size] 1))
  ([size arr toggle]
   (if (zero? size)
     arr
     (if (zero? toggle)
       (recur (- size 2) (conj arr (+ (last arr) size)) 1)
       (recur size (conj arr (+ (last arr) size)) 0)))))

For a board of size 6
it will return the following
[6 10 14 16 18]
i.e. The positions at which directions should be changed.

The other functions will remain same.

For 2nd player the postions will remain same, however in the status atom, cur-pos will start from (6,5) and direction :left.

So I can generalise the arr-maker function and pass 2 as a parameter to solve the problem.

Tommorow after I am done with todo-list problem i'll make the clojure-script implementation of the game.
